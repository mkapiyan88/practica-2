'use strict';

/* Задания на урок:
1) Реализовать функционал, что после заполнения формы и нажатия кнопки "Подтвердить" - 
новый фильм добавляется в список. Страница не должна перезагружаться.
Новый фильм должен добавляться в movieDB.movies.
Для получения доступа к значению input - обращаемся к нему как input.value;
P.S. Здесь есть несколько вариантов решения задачи, принимается любой, но рабочий.
2) Если название фильма больше, чем 21 символ - обрезать его и добавить три точки
3) При клике на мусорную корзину - элемент будет удаляться из списка (сложно)
4) Если в форме стоит галочка "Сделать любимым" - в консоль вывести сообщение: 
"Добавляем любимый фильм"
5) Фильмы должны быть отсортированы по алфавиту */


    // Когда страничка загружается, то все картинки и тд отправляются в виде запроса на сервер. И если они много весят то долше загружаются на  страницу. Но когда делает запрос, он идет дальше внис по дереву кода и упирается в самый низ, где у нас подключается тег с скриптами. И здесь можем  столкнуться с проблемой, что скрипт начнет работать до того, как наша структура будет готова, и тогда нашь скрипт не сможет найти определенные   элементы, а если этих элементов еще не будет на странице, то мы получим ошибку, и код не сработает. И чтобы это не случалось в JS есь событие     которое может это отлавливать "DOMContentLoaded". При помощи данного события мы дожидаемся не полной загрузки всей страницы, а только   DOM-структуры. Потому что полная загрузка может идти 10 секунд и более.
    // И чтобы это событие подключить нужно весь код поместить в collback-функцию данного событи.

document.addEventListener('DOMContentLoaded', () => {

        const adv = document.querySelectorAll('.promo__adv img');
        const poster = document.querySelector('.promo__bg');
        const genre = poster.querySelector('.promo__genre');
        const movieList = document.querySelector('.promo__interactive-list');

    // Также лучше и другие функциональноси поместить в функции.
    // Например у нас есть функциональность по удалению рекламы.

        const deleteAdv = (arr) => {
            arr.forEach(item => {
                item.remove();
            });
        };
        
    // Также и все изменения которые мы делали на странице лучше тоже поместить в функции

        const makeChange = () => {

            genre.textContent = "драма";
        
            poster.style.backgroundImage = 'url("img/bg.jpg")';
        };
        
        

    // Также лучше метод сортировки тоже поместить в функцию, чтобы можно было ее применять не один раз.
    // И также сразу запустим функцию, чтобы все наши фильмы на странице отсортировались.

    const sortArr = (arr) => {
        arr.sort();
    };

        const movieDB = {
            movies: [
                "Логан",
                "Лига справедливости",
                "Ла-ла лэнд",
                "Одержимость",
                "Скотт Пилигрим против..."
            ]
        };

    // Также функционал по созданию новыйх фильмов переводим в функцию "CreatMovieList", для того чтобы этот функционал переиспользовать, когда     пользователь будет каждый раз добавлять новые фильмы.

    // Также функцию необходимо сделать более универсальной. Чтобы функция была независима от конкретных элементов на странийе или в скрипте. Для этого     служат аргументы. Создаем аргументы "films" - это будет наша база данных с фильмами, и "parent" это будет наш родитель на странице где указываются  названия фильмов. 

    // Также после того как мы объявим функцию, нужно ее вызвать,для того чтобы, когда мы в первый раз зашли на страничку, у нас уже был создан     movieList с фильмами чтобы они отображались на странице. "parent" это будет переменная movieList( Тоесть родитель на странице со списком фильмов),  а "Films"  это наша база данных с фильмами "movieDB.movies"


// 3) Задача.

    // Все корзинки сосзданы при помощи CSS. (.delite) Такой класс один на странице. Обращаться будем 1 раз, переменную создавать не будем.

    // a) Когда все фильмы и корзинки сформированны, будем вешать на каждую корзинку обработчик событий ("click") при помощи 'forEach'. И будем говорить, когда мы кликаем на корзинку, то будем удалять родителя у этой карзинки при помощи "parentElement". В "forEach" понадобится 2 аргумента это "btn"- каждая отдельная корзиночка, и "i" нумирация (для того чтобы знать номер по порядку, который удаляем, ведь массив содержит элементы, которые идут строго по порядку)

    // б) Также необходимо удалить удаленный фильм из базы данных при помощи метода "splise". Синтаксс у него такой, что сначала в скобках указываем 2 аргумента: Какой элемент удаляем, в нашем случае"i", и сколько элементов удаляем, в нашем случае 1.

    // в) Также необходимо воспользоваться рекурсией чтобы когда удалялся фильм из базы данных, то удалялась бы и нумирация по фильмам. Тоесть когда мы удаляем элементы из массива, мы хотим чтобы они заного перестраивались, и соответственно нумерация у нас тоже будет перестраиваться. За это отвечает функция "CreatMovieList". Поэтому нам нужно просто вызвать ее в самой себя.

// 5) Задача.

    // Вызываем функцию "sortArra" внутри функции "CreatMovieList" только в аргументе укажем "ilm" - это будет "movieDB.movies". Делаем мы это для того, чтобы когда удалялся фильм, также когда включалась рекурсия, она также сортировала фильмы по порядку.

function CreatMovieList(films, parent) {

    parent.innerHTML = "";
    sortArr(films);
    
    films.forEach((film, i) => {
        parent.innerHTML += `
        <li class="promo__interactive-item">${i + 1} ${film}
                    <div class="delete"></div>
        </li>`;
    });

    document.querySelectorAll('.delete').forEach((btn, i) => {
        btn.addEventListener('click', () => {
            btn.parentElement.remove();
            movieDB.movies.splice(i, 1);

            CreatMovieList(films, parent);
        });
    });

}
        
// 1) Задача.

    // Когда отправляется форма, то отправляются новые данные в массив, который в нутри нашей мини базы данных, и после этого заново строим список фильмов

    // а) Получаем элементы с которыми будем работать.
    // б) Получаем элементы внутри формы.
    // в) Для 4-ого задание также нужно получить checkbox. checkbox - это type атрибута, и чтобы обратиться к type необходимо его укзать в квадратных скобках поставить знак присваивания и в ковычках указать само название type. 

    const addForm = document.querySelector('form.add'),
          addInput = addForm.querySelector('.adding__input'),
          checkbox = addForm.querySelector('[type="checkbox"]');

    // г) Чтобы отследить отправку нашей формы есть обработчик события котрый называется "submit"

    // д) Чтобы отменить стандартное поведение браузера, то нужно обратиться к объекту "event" и к нему присвоить метод "preventDefault". и этот код нужно обязательно прописывать в самом начале кода. Делаем это чтобы страничка не перезагружалась, когда ммы отправляем форму.

    // е) Далее нам нужно будет узнать что имеено пользователь записал в форму( для этого необходимо внутри функции создать новую переменную "NewFilm" и через точку прописать "value" - это то что написано в форме. Тоесть проверяем что написано в форме), и поставил ли он checkbox. (Для этого необходимо также создать внутри функции переменную "Favorite" и внутри прописать обращение к элементу и через точку свойство "checked" Это свойство возвращает булиновое значение "true" или "false")

    // ж) Когда форма будет подтверждаться необходимо создать новый фильм и поместить в базу данных movieDB.movies.  Чтобы добавит фильм нужно к базе данных "movieDB.movies" прменить метод "push" он добавит фильм в конец массива. В скобках push необходимо прописать переменную "NewFilm".

    // з) И также необходимо отсотрировать фильмы по алфавиту(5 задача). Для этого запустим функцию "sortArr" и в аргумент прописываем переменную с нашей базой данных "movieDB.movies".

    // и) Теперь новый фильм необходимо добавить на страницу. Для этого и воспользуемся функцией которая создает новых фильмы на странице "CreatMovieList". Так как мы ее прописали выше, необходимо во внутрь нашй функции прописать вызов функции "CreatMovieList". Аргументы можно не менять так как элементы не меняются.

    // k) Далее необходимо очистить нашу форму, чтобы из нее все данные исчезли. Для этого необходимо обратиться к самой объекту "event", далее к самому элементу, над которым проводим действие "target" и далее использовать метод "reset()".

    // л) Также необходимо прописать условие, что если пользователь просто нажмет на кнопку и появится пустая срока, то условие не выполнится. Тоесть если пременная "NewFilm" будет являться пустой строкой, то добавление фильма и сортировка работать неибудет.
    // "if (NewFilm)" - это условие означает правду (true).


    addForm.addEventListener('submit', (event) => {
        event.preventDefault();


        let newFilm = addInput.value;
        const Favorite = checkbox.checked;

        if (newFilm) {

            if (newFilm.length > 21) {
                newFilm = `${newFilm.substring(0, 22)}...`;
            }
            
            if (Favorite) {
                console.log('Добавляем любимый фильм');
            }

            movieDB.movies.push(newFilm);
            sortArr(movieDB.movies);
    
            CreatMovieList(movieDB.movies, movieList);  
        }

        event.target.reset();
        
    });

// 2) Задача

    // a) Чтобы сделать так чтобы количество символов в названии фильма показывало 21 символ, нужно воспользоваться условием, и это условие  прописать во внутрь условия события "submit"

    // б) Чтобы показать максимум 21 символ необходимо к переменной "NewFilm" использовать метод "substring()". Тоесть данный способ покажет с какого по какой символ показывать на экране. "if (NewFilm.lenght > 21)". Прописываем условие в бектиках чтобы не прописывать + и многоточие.

// 4) Задача.

    // Така как у нас в чекбоксе стоит "checked", и это свойство возвращает нам "true" или "fulse", то это можно проверить при помощи условия.
    // if (Favorite) - возвращает правду, значит условие срабатывает


          
    // / Из за того что Function-expretion работает только после того как мы функцию объявили, то целесообразно все вызовы функции поместить в конце кода.

    CreatMovieList(movieDB.movies, movieList);
    makeChange();
    deleteAdv(adv);

});














